import axelrod as axl
import numpy as np
from numpy import random as rand

strategyList = [axl.Cooperator(), axl.Defector(), axl.TitForTat(), axl.Grudger(), axl.TwoTitsForTat(), axl.SlowTitForTwoTats2(), axl.SuspiciousTitForTat(), axl.SpitefulTitForTat(), axl.SneakyTitForTat(), axl.SlowTitForTwoTats2(), axl.Bully(), axl.HardProber(), axl.Inverse(), axl.Handshake(), axl.OppositeGrudger(),axl.Aggravater()]

def make_game(NumberOfTurns):
    me = axl.Human(name='me')
    players = [strategyList[rand.randint(0,len(strategyList))], me]
    strategy = str(players[0])
    match = axl.Match(players, turns=NumberOfTurns)
    results = match.play()
    #print(results)
    return results, strategy

def file_traverser(file_name):
    File_object = open(file_name, "r+")
    actionList = []
    for line in File_object[-10:]:
        line2 = line.split(',')
        computerMove = line2[4]
        humanmove = line2[5]
        if computerMove == D:
            computerMove = 1
        if computerMove == C:
            computerMove = 0
        if humanMove == D:
            humanMove = 1
        if humanMove == C:
            humanMove = 0
        actionList.append((humanMove, computerMove))
        print(match.history)

    return robotComparisonList, humanComparisonList



def probability_calculator(file_name):
    myscore = 0
    oppscore = 0
    File_object = open(file_name,"r+")
    list = []
    counter = 0
    for line in File_object:
        try:
            #print(line + ' line')
            line2 = line.split(',')
            myscore += int(line2[1])
            oppscore += int(line2[0])
            #print(str(myscore) + ': human score')
            #print(str(oppscore) + ': computer score')
            counter += 1
            if counter % 10 == 0:
                if oppscore == 0:
                    oppscore = 1
                if myscore == 0:
                    myscore = 1
                ratio = myscore/oppscore
                #print(str(ratio) + ': ratio')
                #print(str(myscore) + ': human score')
                #print(str(oppscore) + ': computer score')
                if ratio <= 1:
                    result = 0
                elif ratio > 1:
                    result = 1
                strat = line2[2]
                ratiostrat = strat + ',' + str(result)
                list.append(ratiostrat)
                myscore = 0
                oppscore = 0
        except ValueError:
            counter = 0
    otherlist = []
    newdic = {}
    newcounter = 0
    for i in list:
        #print(i)
        stratresult = i.split(',')
        #print(stratresult)
        answer = stratresult[0]
        resultingvalue = stratresult[1]
        newcounter += 1
        #print(newcounter)
        if stratresult[1] == '1':
            if any(answer in s for s in otherlist):
                #print('wooh')
                newdic[answer] = (newdic[answer] + 1)/len(list)
            else:
                newdic[answer] = 1/len(list)
                otherlist.append(answer)
    #print(newdic)


    return list, newdic, File_object



# for the first run, it must be File_object = open(r"PrisonerDilemma", "w+"), so that the file is created

def store_data(data):
    File_object = open(r"PrisonerDilemma","a")
    total = 0
    totalopp = 0
    for i in data:
        if str(i[0]) == 'C' and str(i[1]) == 'C':
            #added 1 to all of the year values from the original game,
            #to make the ratios more sensible
            years = 2
            oppyears = 2
            str1 = '2 , 2'
            str2 = strategy
            str3 = str1 + ', '+ str2 + ', ' + '1' + ', ' + 'C, C \n'
            File_object.write(str3)
        elif str(i[0]) == 'C' and str(i[1]) == 'D':
            years = 1
            oppyears = 4
            str1 = '4, 1'
            str2 = strategy
            str3 = str1 + ', ' + str2 + ', ' + '.25' + ', ' + 'C, D \n'
            File_object.write(str3)
        elif str(i[0]) == 'D' and str(i[1]) == 'C':
            years = 4
            oppyears = 1
            str1 = '1, 4'
            str2 = strategy
            str3 = str1 + ', '+ str2 + ', ' + '4' + ', ' + 'D, C \n'
            File_object.write(str3)
        elif str(i[0]) == 'D' and str(i[1]) == 'D':
            years = 3
            oppyears = 3
            str1 = '3, 3'
            str2 = strategy
            str3 = str1 + ', '+ str2 + ', ' + '1' + ', ' + 'D, D \n'
            File_object.write(str3)

        total = total + years
        totalopp = totalopp + oppyears
    if totalopp == 0:
        totalopp = 1
    print(total)
    print(totalopp)
    ratio = total/totalopp
    print(ratio)
    if ratio < 1:
        print('you won!')
    elif ratio == 1:
        print('you tied!')
    elif ratio >= 1:
        print('you lost')

def BayesStratChoice(newdic):
    total = 0
    valueList = []
    keyList = []
    for key in newdic:
        total += newdic[key]
    for key in newdic:
        proportion = int(newdic[key])/total
        valueList.append(newdic[key])
        keyList.append(key)

    chosenStrat = np.random.choice(keyList, 1, valueList)
    return chosenStrat


strategyList = [axl.Cooperator(), axl.Defector(), axl.TitForTat(), axl.Grudger(), axl.TwoTitsForTat(), axl.SlowTitForTwoTats2(), axl.SuspiciousTitForTat(), axl.SpitefulTitForTat(), axl.SneakyTitForTat(), axl.Bully(), axl.HardProber(), axl.Inverse(), axl.Handshake(), axl.OppositeGrudger(),axl.Aggravater()]
# def main():
# game_maker, strategy = make_game(10)

listy,newdic,File_object = probability_calculator('PrisonerDilemma')
#print(newdic)
#print('dictionary above')
me = axl.Human(name='me')
if str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Cooperator':
    strat = axl.Cooperator()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Defector':
    strat = axl.Defector()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'TitForTat':
    strat = axl.TitForTat()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Grudger':
    strat = axl.Grudger()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'TwoTitsForTat':
    strat = axl.TwoTitsForTat()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'SlowTitForTwoTats2':
    strat = axl.SlowTitForTwoTats2()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'SuspiciousTitForTat':
    strat = axl.SuspiciousTitForTat()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'SpitefulTitForTat':
    strat = axl.SpitefulTitForTat()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'SneakyTitForTat':
    strat = axl.SneakyTitForTat()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Bully':
    strat = axl.Bully()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'HardProber':
    strat = axl.HardProber()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Inverse':
    strat = axl.Inverse()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Handshake':
    strat = axl.Handshake()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'OppositeGrudger':
    strat = axl.OppositeGrudger()
elif str(BayesStratChoice(newdic)[0].replace(' ', '')) == 'Aggravater':
    strat = axl.Aggravater()
else:
    #print('try a different strategy!')
    #print('this one')
    strat = strategyList[rand.randint(0,len(strategyList))]
    #print(BayesStratChoice(newdic)[0].replace(' ', ''))
    #print(type(BayesStratChoice(newdic)[0].replace(' ', '')))
File_object.close()
players = [strat, me]
strategy = str(players[0])
print(strategy)
match = axl.Match(players, turns=10)
results = match.play()
print(results)
store_data(results)

r = .85

def t4t(last, lastme):
    return last

def defect(last, lastme):
    return 1

def coop(last, lastme):
    return 0

def grudger(last, lastme):
    counter = 0
    if last == 1:
        counter = 1
    if counter == 1:
        return 1
    else:
        return 0

t4t2_counter = 0

def t4t2(last, lastme):
    global t4t2_counter
    if last == 1:
        t4t2_counter = 0
        return 1
    if lastme == 1:
        t4t2_counter += 1
        if t4t2_counter == 2:
            return 0
        else:
            return 1
    return 0

st42t2_counter = 0
st42t2_tracker = 0
def st42t2(last, lastme):
    global st42t2_counter
    global st42t2_tracker
    if st42t2_counter < 2:
        st42t2_tracker = last
        st42t2_counter += 1
        return 0
    else:
        if st42t2_tracker == last:
            return last
        else:
            return lastme

def sus4tat(last, lastme):
    if last == None:
        return 1
    else:
        return last

s4tat_counter = 0
s4tat_counter2 = 0
def spite4tat(last, lastme):
    global s4tat_counter
    global s4tat_counter2
    if last == None:
        return 0
    else:
        if last == 1:
            s4tat_counter += 1
        else:
            s4tat_counter = 0
        if s4tat_counter >= 2:
            s4tat_counter2 = 1
    if s4tat_counter2 == 1:
        return 1
    else:
        return last

sneak4tat_counter = 0
sneak4tat_counter2 = 0
def sneak4tat(last, lastme):
    global sneak4tat_counter
    global sneak4tat_counter2
    if last == None:
        return 0
    if last == 1:
        sneak4tat_counter = 1
        sneak4tat_counter2 += 1
    else:
        sneak4tat_counter2 = 0
    if sneak4tat_counter == 0:
        return 1
    if sneak4tat_counter2 == 2:
        sneak4tat_counter2 = 0
        return 0
    return last

def bully(last, lastme):
    if last == None:
        return 1
    if last == 1:
        return 0
    if last == 0:
        return 1

hardprober_counter = 0
hardprober_counter1 = 0
def hardprober(last, lastme):
    global hardprober_counter
    global hardprober_counter1
    hardprober_counter += 1
    if hardprober_counter == 1:
        return 1
    if hardprober_counter == 2:
        return 0
    if hardprober_counter == 3:
        if last == 0:
            hardprober_counter1 += 1
        return 0
    if hardprober_counter == 4:
        if last == 0:
            hardprober_counter1 += 1
    if hardprober_counter1 == 2:
        return 1
    else:
        return last

inverseCounter = 0
def inverse(last, lastme):
    global inverseCounter
    if last == 1:
        outcome = random.randint(1,100)
        if outcome < inverseCounter:
        inverseCounter += 1
    else:
        inverseCounter = 0
        return 0













t4t2_counter = 0
last = None
lastme = None
base_prob = [1,1,1,1,1,1,1,1,1,1,1]
algs = [t4t, defect, coop, grudger, t4t2, st42t2, sus4tat, spite4tat, sneak4tat, bully, hardprober]
for comp, me in results:
    if str(comp) == 'C':
        comp = 0
    if str(comp) == 'D':
        comp = 1
    if str(me) == 'C':
        me = 0
    if str(me) == 'D':
        me = 1
    for i in range(len(algs)):
        if last is None:
            base_prob[i] *= .5
        if algs[i](last, lastme) == me:
            base_prob[i] *= r
        else:
            base_prob[i] *= (1-r)
    last = comp
    lastme = me

base_prob = np.array(base_prob)

base_prob = base_prob/np.sum(base_prob)
print(base_prob)
